// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: users.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const changeUserPassword = `-- name: ChangeUserPassword :one
UPDATE Users SET password = $2
WHERE username = $1 RETURNING username, password, email, scrobblingenabled, ldapauthenticated, adminrole, settingsrole, streamrole, jukeboxrole, downloadrole, uploadrole, playlistrole, coverartrole, commentrole, podcastrole, sharerole, videoconversionrole, musicfolderid, maxbitrate
`

type ChangeUserPasswordParams struct {
	Username string
	Password string
}

func (q *Queries) ChangeUserPassword(ctx context.Context, arg ChangeUserPasswordParams) (User, error) {
	row := q.db.QueryRow(ctx, changeUserPassword, arg.Username, arg.Password)
	var i User
	err := row.Scan(
		&i.Username,
		&i.Password,
		&i.Email,
		&i.Scrobblingenabled,
		&i.Ldapauthenticated,
		&i.Adminrole,
		&i.Settingsrole,
		&i.Streamrole,
		&i.Jukeboxrole,
		&i.Downloadrole,
		&i.Uploadrole,
		&i.Playlistrole,
		&i.Coverartrole,
		&i.Commentrole,
		&i.Podcastrole,
		&i.Sharerole,
		&i.Videoconversionrole,
		&i.Musicfolderid,
		&i.Maxbitrate,
	)
	return i, err
}

const createAdminUser = `-- name: CreateAdminUser :one
INSERT INTO Users (username, password, email, adminRole)
VALUES ($1, $2, $3, TRUE) 
ON CONFLICT (username) DO UPDATE SET username = EXCLUDED.username
RETURNING username, password, email, scrobblingenabled, ldapauthenticated, adminrole, settingsrole, streamrole, jukeboxrole, downloadrole, uploadrole, playlistrole, coverartrole, commentrole, podcastrole, sharerole, videoconversionrole, musicfolderid, maxbitrate
`

type CreateAdminUserParams struct {
	Username string
	Password string
	Email    string
}

func (q *Queries) CreateAdminUser(ctx context.Context, arg CreateAdminUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createAdminUser, arg.Username, arg.Password, arg.Email)
	var i User
	err := row.Scan(
		&i.Username,
		&i.Password,
		&i.Email,
		&i.Scrobblingenabled,
		&i.Ldapauthenticated,
		&i.Adminrole,
		&i.Settingsrole,
		&i.Streamrole,
		&i.Jukeboxrole,
		&i.Downloadrole,
		&i.Uploadrole,
		&i.Playlistrole,
		&i.Coverartrole,
		&i.Commentrole,
		&i.Podcastrole,
		&i.Sharerole,
		&i.Videoconversionrole,
		&i.Musicfolderid,
		&i.Maxbitrate,
	)
	return i, err
}

const createDefaultUser = `-- name: CreateDefaultUser :one
INSERT INTO Users (username, password, email)
VALUES ($1, $2, $3) 
ON CONFLICT (username) DO UPDATE SET username = EXCLUDED.username
RETURNING username, password, email, scrobblingenabled, ldapauthenticated, adminrole, settingsrole, streamrole, jukeboxrole, downloadrole, uploadrole, playlistrole, coverartrole, commentrole, podcastrole, sharerole, videoconversionrole, musicfolderid, maxbitrate
`

type CreateDefaultUserParams struct {
	Username string
	Password string
	Email    string
}

func (q *Queries) CreateDefaultUser(ctx context.Context, arg CreateDefaultUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createDefaultUser, arg.Username, arg.Password, arg.Email)
	var i User
	err := row.Scan(
		&i.Username,
		&i.Password,
		&i.Email,
		&i.Scrobblingenabled,
		&i.Ldapauthenticated,
		&i.Adminrole,
		&i.Settingsrole,
		&i.Streamrole,
		&i.Jukeboxrole,
		&i.Downloadrole,
		&i.Uploadrole,
		&i.Playlistrole,
		&i.Coverartrole,
		&i.Commentrole,
		&i.Podcastrole,
		&i.Sharerole,
		&i.Videoconversionrole,
		&i.Musicfolderid,
		&i.Maxbitrate,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :one
DELETE FROM Users 
WHERE username = $1 RETURNING username, password, email, scrobblingenabled, ldapauthenticated, adminrole, settingsrole, streamrole, jukeboxrole, downloadrole, uploadrole, playlistrole, coverartrole, commentrole, podcastrole, sharerole, videoconversionrole, musicfolderid, maxbitrate
`

func (q *Queries) DeleteUser(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, deleteUser, username)
	var i User
	err := row.Scan(
		&i.Username,
		&i.Password,
		&i.Email,
		&i.Scrobblingenabled,
		&i.Ldapauthenticated,
		&i.Adminrole,
		&i.Settingsrole,
		&i.Streamrole,
		&i.Jukeboxrole,
		&i.Downloadrole,
		&i.Uploadrole,
		&i.Playlistrole,
		&i.Coverartrole,
		&i.Commentrole,
		&i.Podcastrole,
		&i.Sharerole,
		&i.Videoconversionrole,
		&i.Musicfolderid,
		&i.Maxbitrate,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT username, password, email, scrobblingenabled, ldapauthenticated, adminrole, settingsrole, streamrole, jukeboxrole, downloadrole, uploadrole, playlistrole, coverartrole, commentrole, podcastrole, sharerole, videoconversionrole, musicfolderid, maxbitrate FROM Users
WHERE username = $1 LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.Username,
		&i.Password,
		&i.Email,
		&i.Scrobblingenabled,
		&i.Ldapauthenticated,
		&i.Adminrole,
		&i.Settingsrole,
		&i.Streamrole,
		&i.Jukeboxrole,
		&i.Downloadrole,
		&i.Uploadrole,
		&i.Playlistrole,
		&i.Coverartrole,
		&i.Commentrole,
		&i.Podcastrole,
		&i.Sharerole,
		&i.Videoconversionrole,
		&i.Musicfolderid,
		&i.Maxbitrate,
	)
	return i, err
}

const getUsers = `-- name: GetUsers :many
SELECT username, password, email, scrobblingenabled, ldapauthenticated, adminrole, settingsrole, streamrole, jukeboxrole, downloadrole, uploadrole, playlistrole, coverartrole, commentrole, podcastrole, sharerole, videoconversionrole, musicfolderid, maxbitrate FROM Users
`

func (q *Queries) GetUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.Username,
			&i.Password,
			&i.Email,
			&i.Scrobblingenabled,
			&i.Ldapauthenticated,
			&i.Adminrole,
			&i.Settingsrole,
			&i.Streamrole,
			&i.Jukeboxrole,
			&i.Downloadrole,
			&i.Uploadrole,
			&i.Playlistrole,
			&i.Coverartrole,
			&i.Commentrole,
			&i.Podcastrole,
			&i.Sharerole,
			&i.Videoconversionrole,
			&i.Musicfolderid,
			&i.Maxbitrate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUser = `-- name: UpdateUser :one
UPDATE Users SET
    password = $2,
    email = $3,
    scrobblingEnabled = $4,
    ldapAuthenticated = $5,
    adminRole = $6,
    settingsRole = $7,
    streamRole = $8,
    jukeboxRole = $9,
    downloadRole = $10,
    uploadRole = $11,
    playlistRole = $12,
    coverArtRole = $13,
    commentRole = $14,
    podcastRole = $15,
    shareRole = $16,
    videoConversionRole = $17,
    musicFolderId = $18,
    maxBitRate = $19
WHERE username = $1 RETURNING username, password, email, scrobblingenabled, ldapauthenticated, adminrole, settingsrole, streamrole, jukeboxrole, downloadrole, uploadrole, playlistrole, coverartrole, commentrole, podcastrole, sharerole, videoconversionrole, musicfolderid, maxbitrate
`

type UpdateUserParams struct {
	Username            string
	Password            string
	Email               string
	Scrobblingenabled   bool
	Ldapauthenticated   bool
	Adminrole           bool
	Settingsrole        bool
	Streamrole          bool
	Jukeboxrole         bool
	Downloadrole        bool
	Uploadrole          bool
	Playlistrole        bool
	Coverartrole        bool
	Commentrole         bool
	Podcastrole         bool
	Sharerole           bool
	Videoconversionrole bool
	Musicfolderid       pgtype.Text
	Maxbitrate          int32
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.Username,
		arg.Password,
		arg.Email,
		arg.Scrobblingenabled,
		arg.Ldapauthenticated,
		arg.Adminrole,
		arg.Settingsrole,
		arg.Streamrole,
		arg.Jukeboxrole,
		arg.Downloadrole,
		arg.Uploadrole,
		arg.Playlistrole,
		arg.Coverartrole,
		arg.Commentrole,
		arg.Podcastrole,
		arg.Sharerole,
		arg.Videoconversionrole,
		arg.Musicfolderid,
		arg.Maxbitrate,
	)
	var i User
	err := row.Scan(
		&i.Username,
		&i.Password,
		&i.Email,
		&i.Scrobblingenabled,
		&i.Ldapauthenticated,
		&i.Adminrole,
		&i.Settingsrole,
		&i.Streamrole,
		&i.Jukeboxrole,
		&i.Downloadrole,
		&i.Uploadrole,
		&i.Playlistrole,
		&i.Coverartrole,
		&i.Commentrole,
		&i.Podcastrole,
		&i.Sharerole,
		&i.Videoconversionrole,
		&i.Musicfolderid,
		&i.Maxbitrate,
	)
	return i, err
}
