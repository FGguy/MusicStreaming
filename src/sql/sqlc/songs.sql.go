// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: songs.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSong = `-- name: CreateSong :one
INSERT INTO Songs (album_id, title, album, artist, is_dir, cover_art, created, duration, bit_rate, size, suffix, content_type, is_video)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13) RETURNING song_id, album_id, title, album, artist, is_dir, cover_art, created, duration, bit_rate, size, suffix, content_type, is_video, path
`

type CreateSongParams struct {
	AlbumID     pgtype.Int4
	Title       string
	Album       pgtype.Text
	Artist      pgtype.Text
	IsDir       pgtype.Bool
	CoverArt    pgtype.Text
	Created     pgtype.Timestamp
	Duration    pgtype.Int4
	BitRate     pgtype.Int4
	Size        pgtype.Int4
	Suffix      pgtype.Text
	ContentType pgtype.Text
	IsVideo     pgtype.Bool
}

func (q *Queries) CreateSong(ctx context.Context, arg CreateSongParams) (Song, error) {
	row := q.db.QueryRow(ctx, createSong,
		arg.AlbumID,
		arg.Title,
		arg.Album,
		arg.Artist,
		arg.IsDir,
		arg.CoverArt,
		arg.Created,
		arg.Duration,
		arg.BitRate,
		arg.Size,
		arg.Suffix,
		arg.ContentType,
		arg.IsVideo,
	)
	var i Song
	err := row.Scan(
		&i.SongID,
		&i.AlbumID,
		&i.Title,
		&i.Album,
		&i.Artist,
		&i.IsDir,
		&i.CoverArt,
		&i.Created,
		&i.Duration,
		&i.BitRate,
		&i.Size,
		&i.Suffix,
		&i.ContentType,
		&i.IsVideo,
		&i.Path,
	)
	return i, err
}

const getSong = `-- name: GetSong :one
SELECT song_id, album_id, title, album, artist, is_dir, cover_art, created, duration, bit_rate, size, suffix, content_type, is_video, path FROM Songs
WHERE song_id = $1 LIMIT 1
`

func (q *Queries) GetSong(ctx context.Context, songID int32) (Song, error) {
	row := q.db.QueryRow(ctx, getSong, songID)
	var i Song
	err := row.Scan(
		&i.SongID,
		&i.AlbumID,
		&i.Title,
		&i.Album,
		&i.Artist,
		&i.IsDir,
		&i.CoverArt,
		&i.Created,
		&i.Duration,
		&i.BitRate,
		&i.Size,
		&i.Suffix,
		&i.ContentType,
		&i.IsVideo,
		&i.Path,
	)
	return i, err
}

const getSongs = `-- name: GetSongs :many
SELECT song_id, album_id, title, album, artist, is_dir, cover_art, created, duration, bit_rate, size, suffix, content_type, is_video, path FROM Songs
WHERE album_id = $1
`

func (q *Queries) GetSongs(ctx context.Context, albumID pgtype.Int4) ([]Song, error) {
	rows, err := q.db.Query(ctx, getSongs, albumID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Song
	for rows.Next() {
		var i Song
		if err := rows.Scan(
			&i.SongID,
			&i.AlbumID,
			&i.Title,
			&i.Album,
			&i.Artist,
			&i.IsDir,
			&i.CoverArt,
			&i.Created,
			&i.Duration,
			&i.BitRate,
			&i.Size,
			&i.Suffix,
			&i.ContentType,
			&i.IsVideo,
			&i.Path,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
